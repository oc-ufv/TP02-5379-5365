//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE2_115(

	//////////// LED //////////
	output		     [8:0]		LEDG,
	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		    [17:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,
	output		     [6:0]		HEX6,
	output		     [6:0]		HEX7,

	//////////// LCD //////////
	output		          		LCD_BLON,
	inout 		     [7:0]		LCD_DATA,
	output		          		LCD_EN,
	output		          		LCD_ON,
	output		          		LCD_RS,
	output		          		LCD_RW
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

	wire [31:0] PCFPGA;
	


//=======================================================
//  Structural coding
//=======================================================


	datapath datapathFPGA( 
		.clock(~KEY[0]),
		.reset(~KEY[1]),
		.PCOutDPde2(PCFPGA)
		);

	display disp7(.valorPC(PCFPGA[7:4]), .HEX(HEX7));
	display disp6(.valorPC(PCFPGA[3:0]), .HEX(HEX6));
	
		
endmodule



module add (
    input [31:0] value1, value2,
    output [31:0] out
);

assign out = value1 + value2;

endmodule



module alu (
    input [31:0] aluInput1, aluInput2,
    input [3:0] aluControl,
    output reg [31:0] aluResult,
    output aluZero
);
    
    assign aluZero = (aluResult == 0) ? 1 : 0;

    always @(*)
    begin
        case (aluControl)
        4'b0010: aluResult <= aluInput1 + aluInput2; //lh, sh, add
        4'b0110: aluResult <= aluInput1 - aluInput2; //bne
        4'b0001: aluResult <= aluInput1 | aluInput2; //or
        4'b0000: aluResult <= aluInput1 & aluInput2; //andi
        4'b0100: aluResult <= aluInput1 << aluInput2; //sll
		  default: aluResult = 32'b0;
        endcase
    end

endmodule


module aluControl (
    input [1:0] ALUOp,
    input [2:0] funct3,
    output reg [3:0] aluControlreg
    
);

    always @(*)
    begin
        case (ALUOp) //lh, sh, add, or, andi, sll, bne
            2'b00: aluControlreg <= 4'b0010; //lh e sh
            2'b01: aluControlreg <= 4'b0110; //bne
            2'b11: aluControlreg <= 4'b0000; //andi
            2'b10: case (funct3) 
                3'b000: aluControlreg <= 4'b0010; //add
                3'b110: aluControlreg <= 4'b0001; //or
                3'b001: aluControlreg <= 4'b0100; //sll
            endcase
        endcase
    end
	 
endmodule


module control (
    input [6:0] opcode,
    output reg Branch, MemRead, MemtoReg, MemWrite, ALUSrc, RegWrite,
    output reg [1:0] ALUOp
    //output aluOpCtrl,
);
    reg [7:0] outControl;
    always @(*)
    begin
        case (opcode) //lh, sh, add, or, andi, sll, bne
            7'b0000011: outControl <= 8'b01100011; //lh - Tipo I Certo
            7'b0100011: outControl <= 8'b00000110; //sh = Tipo S Certo
            7'b0110011: outControl <= 8'b00010001; //add, or, sll - Tipo R Certo
            7'b0010011: outControl <= 8'b00011011; //andi - Tipo I Certo
            7'b1100011: outControl <= 8'b10001000; //bne - Tipo SB Certo
            default: outControl <= 8'bx;
        endcase

        Branch <= outControl[7];
        MemRead <= outControl[6];
        MemtoReg <= outControl[5];
        ALUOp <= outControl[4:3];
        MemWrite <= outControl[2];
        ALUSrc <= outControl[1];
        RegWrite <= outControl[0];
    end
	 
endmodule


module dataMemory(
    input clock, reset,
    input [31:0] address, writeData,
    input memRead, memWrite,
    output reg [31:0] readData
);


    reg [31:0] memory [0:127];
    reg [31:0] temp;

    always @(posedge clock or posedge reset) begin
        if (reset) begin
        end else begin
            if (memWrite) begin
                if (address[1] == 0)
                    memory[address >> 2][31:16] <= writeData[15:0];
                else
                    memory[address >> 2][15:0] <= writeData[15:0];
            end
        end
    end

    always @(*) begin
        if (memRead) begin
            if (address[1] == 0)
                readData = {{16{memory[address >> 2][31]}}, memory[address >> 2][31:16]};
            else
                readData = {{16{memory[address >> 2][15]}}, memory[address >> 2][15:0]};
        end else begin
            readData = 32'b0;
        end
    end
endmodule


module immGen (
    input [31:0] instruction,
    output reg [31:0] imm
);
    

    always @(*) begin

        case (instruction[6:0])

            // Tipo I
            7'b0000011: imm <= {{21{instruction[31]}}, instruction[30:20]}; 
            // Tipo S
            7'b0100011: imm <= {{21{instruction[31]}}, instruction[30:25], instruction[11:7]}; 
            // aritmetica + imediato
            7'b0010011: imm <= {{21{instruction[31]}}, instruction[30:20]}; 
            // desvio
            7'b1100011: imm <= {{20{instruction[31]}}, instruction[7], instruction[30:25], instruction[11:8], {1'b0}}; 
            
            default: imm <= 32'bx;

        endcase
    end
    

endmodule


module instructionMem (
    input clock,
    input [31:0] address,
    output reg [31:0] current_instruction
);
 
    reg[31:0] instructions [0:31];


    always @(*) begin
	 
			//Instruções de forma manual na placa aqui
			
			//lh x1, 0(x2)
			instructions[0] = 32'b00000000000000010001000010000011;
			//sh x1, 0(x2)
			instructions[1] = 32'b00000000000100010001000000100011;
			//or x1, x2, x3
			instructions[2] = 32'b00000000001100010110000010110011;
			//andi x1, x2, 10
			instructions[3] = 32'b00000000101000010111000010010011;
			//sll x1, x2, x3
			instructions[4] = 32'b00000000001100010001000010110011;
			//bne x1, x2, 16
			instructions[5] = 32'b00000000001000001001100001100011;
			
			current_instruction <= instructions[address >> 2];
    end


endmodule


module mux (
    input crtlSignal,
    input [31:0] value1, value2,
    output [31:0] out
);
    
    assign out = (crtlSignal == 0)? value2 : value1;

endmodule


module pc (
    input clock, reset,
    input [31:0] pcIn,
    output reg [31:0] pcOut
);
    

    always @(posedge clock) begin
        if (reset) begin
            pcOut <= 32'b0;
        end
        else begin
            pcOut <= pcIn;
        end
    end

endmodule


module regMemory (
    input regWrite,
    input [4:0] readReg1, readReg2, writeReg, 
    input [31:0] writeData,
    output reg [31:0] readData1, readData2,
	 input clock, reset
);
    reg [31:0] registersSet [0:31]; 
	 
	 always @(posedge clock or posedge reset) begin
      if (reset) begin
		
         registersSet[0] <= 32'b0;
         registersSet[1] <= 32'b0;
         registersSet[2] <= 32'b0;
         registersSet[3] <= 32'b0;
         registersSet[4] <= 32'b0;
         registersSet[5] <= 32'b0;
         registersSet[6] <= 32'b0;
         registersSet[7] <= 32'b0;
         registersSet[8] <= 32'b0;
         registersSet[9] <= 32'b0;
         registersSet[10] <= 32'b0;
         registersSet[11] <= 32'b0;
         registersSet[12] <= 32'b0;
         registersSet[13] <= 32'b0;
         registersSet[15] <= 32'b0;
         registersSet[16] <= 32'b0;
         registersSet[17] <= 32'b0;
         registersSet[18] <= 32'b0;
         registersSet[19] <= 32'b0;
         registersSet[20] <= 32'b0;
         registersSet[21] <= 32'b0;
         registersSet[22] <= 32'b0;
         registersSet[23] <= 32'b0;
         registersSet[24] <= 32'b0;
         registersSet[25] <= 32'b0;
         registersSet[26] <= 32'b0;
         registersSet[27] <= 32'b0;
         registersSet[28] <= 32'b0;
         registersSet[29] <= 32'b0;
         registersSet[30] <= 32'b0;
         registersSet[31] <= 32'b0;
      end
      else if (regWrite == 1 && writeReg != 0) begin registersSet[writeReg] <= writeData;
		end
		end

    always @(readReg1, registersSet[readReg1]) begin
        readData1 <= registersSet[readReg1];
        
    end
    
    always @(readReg2, registersSet[readReg2]) begin
        readData2 <= registersSet[readReg2];
        
	end
	
endmodule

module datapath (
    input clock, reset,
	 output [31:0] PCOutDPde2
);

    wire [31:0] PCInDP, PCOutDP, Add1OutDP, Add2OutDP, InsMemOutDP, ReadData1DP, 
                ReadData2DP, ImmGenOutDP, MuxOutAluInDP, WriteDataDP, AluResultDP,
                ReadDataDMOutDP;


	 
    wire ZeroResultDP, BranchDP, MemReadDP, MemtoRegDP, RegWriteDP, ALUSrcDP, MemWriteDP;
    wire [1:0] ALUOpDP;
    wire [3:0] aluControlOutDP;
												
	 assign PCOutDPde2 = PCOutDP;
	 
	 
    add add4DP(
        .value1(PCOutDP),
        .value2(32'b100),
        .out(Add1OutDP)
    );

    add addBranchDP(
        .value1(PCOutDP),
        .value2(ImmGenOutDP),
        .out(Add2OutDP)
    );

    alu aluDP(
        .aluInput1(ReadData1DP),
        .aluInput2(MuxOutAluInDP),
        .aluControl(aluControlOutDP),
        .aluResult(AluResultDP),
        .aluZero(ZeroResultDP)
    );

    aluControl aluControlDP(
      .ALUOp(ALUOpDP),
      .funct3(InsMemOutDP[14:12]),
      .aluControlreg(aluControlOutDP)
    );
    
    control controlDP(
        .opcode(InsMemOutDP[6:0]),
        .Branch(BranchDP),
        .MemRead(MemReadDP),
        .ALUOp(ALUOpDP),
        .MemtoReg(MemtoRegDP),
        .MemWrite(MemWriteDP),
        .ALUSrc(ALUSrcDP),
        .RegWrite(RegWriteDP)
    );

    dataMemory dataMemoryDP(
        .clock(clock),
        .reset(reset),
        .address(AluResultDP),
        .writeData(ReadData2DP),
        .memRead(MemReadDP),
        .memWrite(MemWriteDP),
        .readData(ReadDataDMOutDP)
    );

    immGen immGenDP(
        .instruction(InsMemOutDP),
        .imm(ImmGenOutDP)
    );
    
    mux muxALUDP(
        .crtlSignal(ALUSrcDP),
        .value1(ImmGenOutDP),
        .value2(ReadData2DP),
        .out(MuxOutAluInDP)
    );

    mux muxBranchDP(
        .crtlSignal(BranchDP & ZeroResultDP),
        .value1(Add2OutDP),
        .value2(Add1OutDP),
        .out(PCInDP)
    );

    mux muxDMDP(
        .crtlSignal(MemtoRegDP),
        .value1(ReadDataDMOutDP),
        .value2(AluResultDP),
        .out(WriteDataDP)
    );
    
    instructionMem instructionMemDP(
        .clock(clock),
        .address(PCOutDP),
        .current_instruction(InsMemOutDP)
    );

    pc pcDP(
        .clock(clock),
        .reset(reset),
        .pcIn(PCInDP),
        .pcOut(PCOutDP)
    );

    regMemory regMemoryDP(
        .regWrite(RegWriteDP),
        .readReg1(InsMemOutDP[19:15]),
        .readReg2(InsMemOutDP[24:20]),
        .writeData(WriteDataDP),
        .readData1(ReadData1DP),
        .readData2(ReadData2DP),
        .writeReg(InsMemOutDP[11:7]),
		  .clock(clock),
		  .reset(reset)
    );
    
endmodule


module display (
    input [3:0] valorPC,
    output reg [6:0] HEX
);

    always @(*) begin
        case (valorPC)
            4'b0000: HEX = 7'b1000000; // valor 0
            4'b0001: HEX = 7'b1111001; // valor 1
            4'b0010: HEX = 7'b0100100; // valor 2
            4'b0011: HEX = 7'b0110000; // valor 3
            4'b0100: HEX = 7'b0011001; // valor 4
            4'b0101: HEX = 7'b0010010; // valor 5
            4'b0110: HEX = 7'b0000010; // valor 6
            4'b0111: HEX = 7'b1111000; // valor 7
            4'b1000: HEX = 7'b0000000; // valor 8
            4'b1001: HEX = 7'b0010000; // valor 9
            4'b1010: HEX = 7'b0001000; // valor A
            4'b1011: HEX = 7'b0000011; // valor B
            4'b1100: HEX = 7'b1000110; // valor C
            4'b1101: HEX = 7'b0100001; // valor D
            4'b1110: HEX = 7'b0000110; // valor E
            4'b1111: HEX = 7'b0001110; // valor F
            default: HEX = 7'b0111111; // Mostra apenas uma barra, indicando valor indefinido
        endcase
    end
endmodule